/*{
  "type": "action",
  "targets": ["omnifocus"],
  "author": "Chad Harp (improved fork of Bastian Kuhn's original)",
  "identifier": "com.harpchad.omnifocus.sync.jira-improved",
  "version": "2.4",
  "description": "Improved Jira-OmniFocus sync with secure credentials, error handling, and performance enhancements",
  "label": "ðŸ”¹ Jira: Sync",
  "shortLabel": "Jira: sync"
}*/
(() => {
  const credentials = new Credentials();
  
  // Helper function to extract plain text from Atlassian Document Format (ADF)
  const extractTextFromADF = (doc) => {
    if (!doc || !doc.content) {
      return "No description";
    }
    
    const textParts = [];
    
    const processNode = (node) => {
      if (node.type === 'text') {
        textParts.push(node.text);
      } else if (node.content) {
        node.content.forEach(processNode);
      }
    };
    
    doc.content.forEach((node, i) => {
      processNode(node);
      // Add paragraph breaks
      if (i < doc.content.length - 1 && node.type === 'paragraph') {
        textParts.push('\n');
      }
    });
    
    return textParts.join('') || "No description";
  };
  
  const action = new PlugIn.Action((selection, sender) => {
    // Configuration
    const jiraUrl = "https://ncmassociates.atlassian.net";
    const credentialKey = "jira-ncm";
    const omnifocusTagToUse = "jira";
    const jiraQuery = "assignee=currentuser() and resolution is empty";
    const processComments = false;
    const omnifocusCommentTagToUse = "Jira-Comment";
    const syncDueDates = true; // Set to true to sync Jira due dates to OmniFocus
    
    // Constants
    const JIRA_API_SEARCH_PATH = "/rest/api/3/search/jql";
    const JIRA_API_COMMENT_PATH = "/rest/api/3/issue";
    const JIRA_BROWSE_PATH = "/browse/";
    const HTTP_ERROR_THRESHOLD = 400;
    const HTTP_UNAUTHORIZED = 401;
    const HTTP_FORBIDDEN = 403;
    const HTTP_NOT_FOUND = 404;
    const CONTENT_TYPE_JSON = "application/json";
    const DEFAULT_NO_DESCRIPTION = "No description";
    const DEFAULT_NO_TITLE = "No title";
    const JIRA_TICKET_REGEX = /^[A-Z][A-Z0-9]{0,9}-[0-9]{1,6}/;
    const JIRA_COMMENT_REGEX = /^[A-Z][A-Z0-9]{0,9}-[0-9]{1,6} [0-9]+/;
    
    try {
      // Retrieve credentials
      const credential = credentials.read(credentialKey);
      
      if (!credential) {
        // Prompt for credentials
        const form = new Form();
        form.addField(new Form.Field.String("user", "Jira Username/Email", null));
        form.addField(new Form.Field.Password("password", "Jira API Token", null));
        
        form.show(`Enter credentials for ${jiraUrl}`, "Save").then((formObject) => {
          const user = formObject.values.user;
          const password = formObject.values.password;
          
          if (user && password) {
            credentials.write(credentialKey, user, password);
            new Alert("Credentials Saved", "Credentials saved to Keychain.\n\nPlease run sync again.").show();
          } else {
            new Alert("Validation Error", "Username and password are required.").show();
          }
        }).catch((err) => {
          if (!err.causedByUserCancelling) {
            new Alert("Error", err.message).show();
          }
        });
        return;
      }
      
      // We have credentials, proceed with sync
      const user = credential.user;
      const password = credential.password;
      
      let fields = "key,summary,description";
      if (syncDueDates) {
        fields += ",duedate";
      }
      const urlParams = `${JIRA_API_SEARCH_PATH}?jql=${encodeURIComponent(jiraQuery)}&fields=${fields}`;
      const url = jiraUrl + urlParams;
      
      console.log(`DEBUG: Fetching URL: ${url}`);
      console.log(`DEBUG: User: ${user}`);
      
      const data = Data.fromString(`${user}:${password}`);
      const authCredentials = data.toBase64();
      
      const request = URL.FetchRequest.fromString(url);
      request.method = "GET";
      request.headers = { Authorization: `Basic ${authCredentials}` };
      
      console.log("DEBUG: Request created, about to fetch...");
      
      // Find or create the tag
      const tag = tags.byName(omnifocusTagToUse) || flattenedTags.byName(omnifocusTagToUse) || new Tag(omnifocusTagToUse);
      
      if (!tag) {
        throw new Error(`Could not create tag: ${omnifocusTagToUse}`);
      }
      
      const tasks = tag.tasks;
      const omnifocusTasks = {};
      
      tasks.forEach((task) => {
        try {
          const match = task.name.match(JIRA_TICKET_REGEX);
          if (match) {
            const taskId = match[0];
            omnifocusTasks[taskId] = task;
            omnifocusTasks[taskId].jiraToOmnifocusMatched = false;
          }
        } catch(e) {
          console.error(`Error parsing task: ${task.name}`);
        }
      });
      
      const requestPromise = request.fetch();
      
      requestPromise.then((response) => {
        let createdTasks = 0;
        let checkedTickets = 0;
        
        console.log(`DEBUG: Response status: ${response.statusCode}`);
        console.log(`DEBUG: Response MIME type: ${response.mimeType}`);
        
        if (response.statusCode >= HTTP_ERROR_THRESHOLD) {
          let errorMsg = `Jira API error (${response.statusCode})`;
          if (response.statusCode === HTTP_UNAUTHORIZED) {
            errorMsg += ": Authentication failed.\n\n";
            errorMsg += "Your API token is invalid or expired.\n";
            errorMsg += "Clearing stored credentials...\n\n";
            errorMsg += "Please run sync again to enter new credentials.";
            
            // Clear the bad credentials
            try {
              credentials.remove(credentialKey);
              console.log("Cleared invalid credentials from keychain");
            } catch(e) {
              console.error(`Failed to clear credentials: ${e.message}`);
            }
          } else if (response.statusCode === HTTP_FORBIDDEN) {
            errorMsg += ": Access forbidden. Verify permissions.";
          } else if (response.statusCode === HTTP_NOT_FOUND) {
            errorMsg += ": Jira instance not found.";
          } else if (response.statusCode === 410) {
            errorMsg += `: Endpoint deprecated/gone.\n\nURL: ${url}`;
          } else {
            errorMsg += `\n\nResponse: ${response.bodyString.substring(0, 200)}`;
          }
          throw new Error(errorMsg);
        }
        
        if (response.mimeType !== CONTENT_TYPE_JSON) {
          throw new Error(`Unexpected response type: ${response.mimeType}\n\nThis usually means the server returned an error page.`);
        }
        
        let jsonResponse;
        try {
          jsonResponse = JSON.parse(response.bodyString);
        } catch(parseError) {
          throw new Error(`Failed to parse JSON response.\n\nResponse: ${response.bodyString.substring(0, 200)}`);
        }
        
        console.log(`DEBUG: Response keys: ${Object.keys(jsonResponse).join(", ")}`);
        
        // The new API might return 'values' instead of 'issues'
        const issues = jsonResponse.issues || jsonResponse.values;
        
        if (!issues) {
          throw new Error(`Invalid Jira response: missing 'issues' or 'values' field. Keys: ${Object.keys(jsonResponse).join(", ")}`);
        }
        
        console.log(`DEBUG: Found ${issues.length} issues`);
        issues.forEach((issue, j) => {
          if (!issue) {
            console.error(`ERROR: Issue at index ${j} is null/undefined`);
            return;
          }
          
          // Log first issue structure for debugging
          if (j === 0) {
            console.log(`DEBUG: First issue keys: ${Object.keys(issue).join(", ")}`);
            if (issue.fields) {
              console.log(`DEBUG: Fields keys: ${Object.keys(issue.fields).join(", ")}`);
            }
          }
          
          checkedTickets++;
          
          const issueKey = issue.key || issue.id;
          if (!issueKey) {
            console.error("ERROR: Issue has no key or id");
            return;
          }
          
          if (omnifocusTasks[issueKey]) {
            const existingTask = omnifocusTasks[issueKey];
            existingTask.markIncomplete();
            existingTask.jiraToOmnifocusMatched = true;
            
            // Update due date if enabled and available
            if (syncDueDates && issue.fields && issue.fields.duedate) {
              try {
                const dueDate = new Date(issue.fields.duedate);
                existingTask.dueDate = dueDate;
                console.log(`DEBUG: Updated due date for ${issueKey}: ${dueDate}`);
              } catch(e) {
                console.error(`ERROR: Failed to parse due date for ${issueKey}: ${e.message}`);
              }
            } else if (syncDueDates && issue.fields && !issue.fields.duedate) {
              // Clear due date if Jira issue has no due date
              existingTask.dueDate = null;
              console.log(`DEBUG: Cleared due date for ${issueKey}`);
            }
            
            return;
          }
          
          // Create new task - handle different response structure
          let summary = DEFAULT_NO_TITLE;
          let description = DEFAULT_NO_DESCRIPTION;
          
          if (issue.fields) {
            summary = issue.fields.summary || DEFAULT_NO_TITLE;
            
            // Handle new Jira Cloud description format (Document/ADF)
            const descField = issue.fields.description;
            if (descField && typeof descField === 'object' && descField.type === 'doc') {
              // Extract plain text from Atlassian Document Format
              description = extractTextFromADF(descField);
            } else if (typeof descField === 'string') {
              description = descField;
            } else if (descField) {
              description = DEFAULT_NO_DESCRIPTION;
            }
          } else if (issue.summary) {
            summary = issue.summary;
            description = issue.description || DEFAULT_NO_DESCRIPTION;
          }
          
          const taskName = `${issueKey} ${summary}`;
          const newTask = new Task(taskName, inbox.beginning);
          const taskUrl = `${jiraUrl}${JIRA_BROWSE_PATH}${issueKey}`;
          createdTasks++;
          
          newTask.addTag(tag);
          newTask.note = `${taskUrl}\n${description}`;
          
          // Set due date if enabled and available
          if (syncDueDates && issue.fields && issue.fields.duedate) {
            try {
              const dueDate = new Date(issue.fields.duedate);
              newTask.dueDate = dueDate;
              console.log(`DEBUG: Set due date for ${issueKey}: ${dueDate}`);
            } catch(e) {
              console.error(`ERROR: Failed to parse due date for ${issueKey}: ${e.message}`);
            }
          }
        });
        
        // Close unmatched tasks
        Object.keys(omnifocusTasks).forEach((taskKey) => {
          const existingTask = omnifocusTasks[taskKey];
          if (!existingTask.jiraToOmnifocusMatched) {
            let canDelete = true;
            if (existingTask.hasChildren) {
              const children = existingTask.children;
              for (let k = 0; k < children.length; k++) {
                if (!children[k].completed) {
                  canDelete = false;
                  break;
                }
              }
            }
            if (canDelete) {
              existingTask.markComplete();
            }
          }
        });
        
        new Alert("Jira Sync Complete", 
          `Synced ${jiraUrl}\n` +
          `âœ“ Checked ${checkedTickets} tickets\n` +
          `âœ“ Created ${createdTasks} new tasks`
        ).show();
        
        console.log(`SUCCESS: Synced ${jiraUrl}. Checked ${checkedTickets} tickets, Created ${createdTasks} new tasks`);
        
      }).catch((err) => {
        new Alert("Jira Sync Failed", 
          `Failed to sync ${jiraUrl}\n\n` +
          `Error: ${err.message}\n\n` +
          "Check Console.app for details."
        ).show();
        
        console.error(`ERROR: Jira sync failed: ${err.message}`);
      });
      
    } catch(err) {
      new Alert("Error", err.toString()).show();
      console.error(err);
    }
  });
  
  action.validate = (selection, sender) => true;
  
  return action;
})();
