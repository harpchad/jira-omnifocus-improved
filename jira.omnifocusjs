/*{
  "type": "action",
  "targets": ["omnifocus"],
  "author": "Bastian Kuhn",
  "identifier": "de.bastian-kuhn.omnifocus.sync.jira",
  "version": "1.3",
  "description": "Sync elements from Jira with Omnifocus",
  "label": "ðŸ”¹ Jira: Sync",
  "shortLabel": "Jira: sync"
}*/
(() => {
  const action = new PlugIn.Action(function (selection, sender) {
    // START EDIT
    // Configuration for each Jira instance
    // Credentials are now stored securely in macOS Keychain
    // On first run, you'll be prompted to enter credentials for each jiraUrl
    const configs = [{
        jiraUrl: "", // e.g., "https://yourcompany.atlassian.net"
        credentialKey: "jira-default", // Unique key for this Jira instance's credentials in Keychain
        omnifocusTagToUse: "Jira", // you can also use the format "Parent1 : Parent2 : Child"
        jiraQuery: "assignee=currentuser() and resolution is empty",
        processComments: false, // if true, a subtask is added for each ticket comment
        omnifocusCommentTagToUse: "Jira-Comment",
    }]
    // Example for multiple Jira instances:
    // {
    //     jiraUrl: "https://secondcompany.atlassian.net",
    //     credentialKey: "jira-secondary",
    //     omnifocusTagToUse: "Jira-Secondary",
    //     jiraQuery: "assignee=currentuser() and resolution is empty",
    //     processComments: false,
    //     omnifocusCommentTagToUse: "Jira-Comment-Secondary",
    // }
    // END EDIT

    configs.forEach((config) => {
        const jiraUrl = config.jiraUrl;
        const credentialKey = config.credentialKey;
        const omnifocusTagToUse = config.omnifocusTagToUse;
        const jiraQuery = config.jiraQuery;
        const processComments = config.processComments;
        const omnifocusCommentTagToUse = config.omnifocusCommentTagToUse;

        // Retrieve credentials from Keychain
        // If not found, prompt user to enter them
        const credential = Credential.read(credentialKey);
        if (!credential) {
          // Prompt for credentials on first run
          const form = new Form();
          form.addField(new Form.Field.String("user", "Jira Username/Email", null));
          form.addField(new Form.Field.Password("password", "Jira API Token", null));
          const formPromise = form.show(`Enter credentials for ${jiraUrl}`, "Save");
          
          formPromise.then((formObject) => {
            const user = formObject.values.user;
            const password = formObject.values.password;
            
            // Save to Keychain
            Credential.write(credentialKey, user, password);
            
            console.log(`INFO: Credentials saved to Keychain for ${credentialKey}. Please run sync again.`);
          }).catch((err) => {
            console.error(`ERROR: Failed to save credentials for ${credentialKey}: ${err}`);
          });
          return; // Exit this config iteration, credentials will be available on next run
        }

        const user = credential.user;
        const password = credential.password;

        const urlParams = "/rest/api/2/search?jql=" + encodeURIComponent(jiraQuery);
        const url = jiraUrl + urlParams;

        const data = Data.fromString(user + ":" + password);
        const credentials = data.toBase64();

        const request = URL.FetchRequest.fromString(url);
        request.method = "GET";
        request.headers = { Authorization: `Basic ${credentials}` };
        const requestPromise = request.fetch();


        // Find the tag
        let tag = null;

        // If user gave an absolute path, parse it and process it
        const parsedOmnifocusTagToUse = omnifocusTagToUse.split(" : ");
        if (parsedOmnifocusTagToUse.length > 1) {
          let currentTag = null;
          let i;
          for (i = 0; i < parsedOmnifocusTagToUse.length; i++) {
            let newTag;
            if (currentTag) {
              newTag = currentTag.childNamed(parsedOmnifocusTagToUse[i]);
            } else {
              newTag = tags.byName(parsedOmnifocusTagToUse[i]);
            }
            if (!newTag) break;
            currentTag = newTag;
          }

          // after all ran, check if its a success, then apply tag
          if (
            currentTag &&
            i === parsedOmnifocusTagToUse.length &&
            currentTag.name ===
              parsedOmnifocusTagToUse[parsedOmnifocusTagToUse.length - 1]
          ) {
            tag = currentTag;
          }
        }
        if (!tag) {
          // if tag is not found yet
          tag =
            tags.byName(omnifocusTagToUse) ||
            flattenedTags.byName(omnifocusTagToUse) ||
            new Tag(omnifocusTagToUse);
        }
        if (!tag) {
          console.error(new Error("could not create tag"));
          return;
        }
        const tasks = tag.tasks;

        const omnifocusComments = {};
        if (processComments) {
          // Get all comment tagged tasks
          var commentTag =
            tags.byName(omnifocusCommentTagToUse) ||
            flattenedTags.byName(omnifocusCommentTagToUse) ||
            new Tag(omnifocusCommentTagToUse);

            const commentTasks = commentTag.tasks;
            commentTasks.forEach((comment) => {
              const re = new RegExp(`^[A-Za-z0-9-]+ [0-9]+`);
              let commentId;
              try {
                commentId = comment.name.match(re);
                if (!commentId) return;
              } catch {
                return;
              }
              omnifocusComments[commentId] = comment;
            });
        }

        // cache object instead of array so search will be faster later
        let omnifocusTasks = {};
        tasks.forEach((task) => {
          const re = new RegExp(`^[A-Za-z0-9-]+`);
          let taskId;
          try {
            taskId = task.name.match(re)[0];
            if (!taskId) return;
          } catch {
            return;
          }
          omnifocusTasks[taskId] = task;
          // Reset Jira Match Flag
          omnifocusTasks[taskId].jiraToOmnifocusMatched = false;
        });

        requestPromise.then((response) => {
          let createdTasks = 0;
          let checkedTickets = 0;
          let createdComments = 0;
          
          // Validate response
          if (!response) {
            throw new Error("No response received from Jira API");
          }
          
          if (response.statusCode >= 400) {
            let errorMsg = `Jira API error (${response.statusCode})`;
            if (response.statusCode === 401) {
              errorMsg += ": Authentication failed. Check credentials in Keychain.";
            } else if (response.statusCode === 403) {
              errorMsg += ": Access forbidden. Verify API token permissions.";
            } else if (response.statusCode === 404) {
              errorMsg += ": Jira instance not found. Check jiraUrl in config.";
            }
            throw new Error(errorMsg);
          }
          
          if (response.mimeType !== "application/json") {
            throw new Error(`Unexpected response type: ${response.mimeType}. Expected application/json`);
          }
          
          let jsonResponse;
          try {
            jsonResponse = JSON.parse(response.bodyString);
          } catch (parseError) {
            throw new Error(`Failed to parse Jira response: ${parseError.message}`);
          }
          
          if (!jsonResponse.issues) {
            throw new Error("Invalid Jira response: missing 'issues' field");
          }
          
          // ADD THE TASKS

            for (const issue of jsonResponse.issues) {
              try {
                // Validate issue data
                if (!issue.key || !issue.fields) {
                  console.error(`WARNING: Skipping invalid issue: ${JSON.stringify(issue)}`);
                  continue;
                }
                
                // Search if we need to add a new Task
                checkedTickets++;
                if (omnifocusTasks[issue.key]) {
                  // Make sure the task opens again
                  omnifocusTasks[issue.key].markIncomplete();
                  omnifocusTasks[issue.key].jiraToOmnifocusMatched = true;
                  continue;
                }

                // There was no Matching Task, so we create the Task
                const taskName = issue.key + " " + (issue.fields.summary || "No title");
                const newTask = new Task(taskName, inbox.beginning);
                const taskUrl = jiraUrl + "/browse/" + issue.key;
                createdTasks++;

                newTask.addTag(tag);
                newTask.note =
                  taskUrl + "\n" + (issue.fields.description || "No description");
              } catch (issueError) {
                console.error(`ERROR: Failed to process issue ${issue?.key || 'unknown'}: ${issueError.message}`);
              }
            }


            //Close Tasks or Update comments if enabled
            for (const [task_id, task] of Object.entries(omnifocusTasks)) {
              if (!task.jiraToOmnifocusMatched) {
                  var can_delete = true;

                  if(task.hasChildren){
                      task.children.forEach(subtask => {
                          if (!subtask.completed){
                            can_delete = false;
                          }
                      });
                  }
                  if(can_delete) {
                    task.markComplete();
                  }
                }
                // Better check anyway, may the ticket is just reasigned
                if (processComments) {
                    const commentUrlParams = "/rest/api/2/issue/"+task_id +"/comment"
                    const commentUrl = jiraUrl + commentUrlParams;
                    const commentRequest = URL.FetchRequest.fromString(commentUrl);
                    commentRequest.method = "GET";
                    commentRequest.headers = { Authorization: `Basic ${credentials}` };
                    var requestPromiseComment = commentRequest.fetch();
                    requestPromiseComment.then((commentResponse) => {
                        try {
                          if (commentResponse.statusCode >= 400) {
                            console.error(`WARNING: Failed to fetch comments for ${task_id} (${commentResponse.statusCode})`);
                            return;
                          }
                          
                          const jsonComments = JSON.parse(commentResponse.bodyString);
                          if (!jsonComments.comments) {
                            console.error(`WARNING: Invalid comment response for ${task_id}`);
                            return;
                          }
                          
                          for (const comment of jsonComments.comments) {
                              const comment_id = task_id + " " + comment.id;
                              if (!omnifocusComments[comment_id] ) {
                                  const taskName = comment_id + " Comment:\n" + comment.body;
                                  const newTask = new Task(taskName, task);
                                  newTask.addTag(commentTag);
                                  createdComments++;
                              }
                          }
                        } catch (commentError) {
                          console.error(`ERROR: Failed to process comments for ${task_id}: ${commentError.message}`);
                        }
                    }).catch((commentErr) => {
                      console.error(`ERROR: Comment fetch failed for ${task_id}: ${commentErr.message}`);
                    });
                }
            };
          
          // Show success notification
          const alert = new Alert("Jira Sync Complete", 
            `Synced ${jiraUrl}\n` +
            `âœ“ Checked ${checkedTickets} tickets\n` +
            `âœ“ Created ${createdTasks} new tasks\n` +
            `âœ“ Added ${createdComments} comment subtasks`
          );
          alert.show();
          
          console.log(`SUCCESS: Synced ${jiraUrl}. Checked ${checkedTickets} Tickets, Created ${createdTasks} new tasks, Added ${createdComments} Subtickets for Comments`);
        });

        requestPromise.catch((err) => {
          // Show error notification to user
          const errorAlert = new Alert("Jira Sync Failed", 
            `Failed to sync ${jiraUrl}\n\n` +
            `Error: ${err.message}\n\n` +
            `Check Console.app for details.`
          );
          errorAlert.show();
          
          console.error(`ERROR: Jira sync failed for ${jiraUrl}: ${err.message}`);
          console.error(`Stack: ${err.stack || 'No stack trace available'}`);
        });
    });

  });

  action.validate = function (selection, sender) {
    //
    // This action is always valid.
    //
    return true;
  };

  return action;
})();
